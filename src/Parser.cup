import ast.access.Access;
import ast.access.ArrayAccess;
import ast.access.VariableAccess;
import ast.block.Block;
import ast.block.BlockContent;
import ast.block.Blocks;
import ast.block.stmt.loop.Break;
import ast.block.stmt.loop.Continue;
import ast.block.stmt.Statement;
import ast.block.stmt.assignment.*;
import ast.block.stmt.conditional.casestmt.Cases;
import ast.block.stmt.conditional.casestmt.Switch;
import ast.block.stmt.conditional.ifstmt.If;
import ast.block.stmt.loop.For;
import ast.block.stmt.loop.Foreach;
import ast.block.stmt.loop.Repeat;
import ast.dcl.variable.*;
import ast.constant.Expression;
import ast.constant.binary.arithmatic.*;
import ast.constant.binary.logical.*;
import ast.constant.constant.*;
import ast.constant.other.Casting;
import ast.constant.other.SizeOf;
import ast.constant.other.Variable;
import ast.constant.unary.arithmatic.*;
import ast.constant.unary.logical.Not;
import ast.program.Program;
import ast.program.ProgramContent;
import ast.program.global.GlobalVarDCL;
import ast.type.CastingType;
import ast.type.StructureType;
import ast.type.Type;
import ast.type.VariableType;

parser code
    {:
        private Scanner scanner;
        public Parser(Scanner scanner) {
            this.scanner = scanner;
        }
    :};

scan with {: return scanner.next_token(); :};


//TERMINALS

//keywords
terminal CONST, RECORD, BOOL, CHAR, INT, LONG, FLOAT, DOUBLE, STRING, VOID, TRUE, FALSE, EXTERN, AUTO, FUNCTION,
BEGIN, END, IF, ELSE, SWITCH, OF, CASE, DEFAULT, FOR, FOREACH, IN, REPEAT, UNTIL, BREAK, CONTINUE, RETURN, SIZEOF;

//operators
terminal SEMI, COL, COMA, DOT, BINOT, PLUS, MINUS, UMINUS, MULT, DIVIDE, MOD, ASSIGN, BIAND, BIOR, BIEXOR, NOT, AND,
OR, LT, GT, BRACKOP, BRACKCL, PRANTOP, PRANTCL, CASTPRANTOP, FUNCPRANTOP, PREFPLUS2, PREFMINUS2, POSTPLUS2, POSTMINUS2,
PLUSASSIGN, MINUSASSIGN, MULTASSIGN, DIVASSIGN, NOTEQ, EQEQ, LTEQ, GTEQ;

//literals
terminal CHAR_LIT, STR_LIT;
terminal Integer INT_LIT;
terminal Double FLOAT_LIT;
terminal String ID;

//NON TERMINALS

nonterminal program;
nonterminal program_part;

nonterminal ProgramContent global_var_dcl;
nonterminal Type variable_type;

nonterminal ProgramContent func_dcl;
nonterminal Block func_dcl_part;
nonterminal arguments;
nonterminal arguments_part;
nonterminal Boolean function_array_dcl;
nonterminal Type function_return_type;
nonterminal Type function_argument_type;

nonterminal ProgramContent struct_dcl;
nonterminal StructVarDCL struct_var_dcl;
nonterminal struct_more_var_dcl;
nonterminal StructVarDCL struct_var_dcl_part;
nonterminal StructVarDCL struct_var_dcl_cnt;
nonterminal Type struct_type;

nonterminal Block block;
nonterminal BlockContent block_content;
nonterminal Block loop_block;
nonterminal BlockContent loop_block_content;

nonterminal var_dcl;
nonterminal var_dcl_part;
nonterminal BlockContent var_dcl_cnt;
nonterminal Expression var_dcl_cnt_part;
nonterminal var_dcl_cnt_extension;
nonterminal VarDCL single_var;
nonterminal VarDCL array_part;

nonterminal BlockContent statement;
nonterminal BlockContent loop_statement;

nonterminal Statement cond_stmt;
nonterminal Block else_part;
nonterminal case_part;

nonterminal Statement loop_stmt;
nonterminal Assignment loop_init_part;
nonterminal Expression loop_cond_part;
nonterminal Assignment loop_update_part;

nonterminal Assignment assignment;
nonterminal Access variable;
nonterminal Access var_access;
nonterminal Access var_access_array_part;

nonterminal Expression constant;
nonterminal Type casting_type;
nonterminal Expression arithmatic_expr;
nonterminal Expression conditional_expr;
nonterminal Constant const_val;

nonterminal FunctionAccess function_call;
nonterminal parameters;
nonterminal parameters_part;


//PRECEDENCES

precedence right MULTASSIGN, DIVASSIGN;
precedence right PLUSASSIGN, MINUSASSIGN;
precedence right ASSIGN;
precedence left OR;
precedence left AND;
precedence left BIOR;
precedence left BIEXOR;
precedence left BIAND;
precedence left EQEQ, NOTEQ;
precedence left GT, GTEQ;
precedence left LT, LTEQ;
precedence left PLUS, MINUS;
precedence left MULT, DIVIDE, MOD;
precedence right SIZEOF;
precedence right NOT, BINOT;
precedence right CASTPRANTOP;
precedence right UMINUS;
precedence left PRANTOP;
precedence right PREFPLUS2, PREFMINUS2;
precedence left DOT;
precedence left BRACKOP;
precedence left FUNCPRANTOP;
precedence left POSTPLUS2, POSTMINUS2;


start with program;


//GRAMMER PRODUCTION RULES

//program
program ::=
    program_part program
    |
    /*epsilon*/
    ;

program_part ::=
    global_var_dcl:cont {:Program.getInstance().addContent(cont);:}
    |
    func_dcl:cont {:Program.getInstance().addContent(cont);:}
    |
    struct_dcl:cont {:Program.getInstance().addContent(cont);:}
    ;


//global variables
global_var_dcl ::=
    variable_type:t ID:id {:id = scanner.string.toString();:} SEMI {:RESULT = new GlobalVarDCL(t, id);:}
    ;

variable_type ::=
    BOOL {:RESULT = Type.BOOL;:}
    |
    CHAR {:RESULT = Type.CHAR;:}
    |
    INT {:RESULT = Type.INT;:}
    |
    LONG {:RESULT = Type.LONG;:}
    |
    FLOAT {:RESULT = Type.FLOAT;:}
    |
    DOUBLE {:RESULT = Type.DOUBLE;:}
    |
    STRING {:RESULT = Type.STRING;:}
    |
    AUTO {:RESULT = Type.AUTO;:}
    |
    ID:type {:new Type(type);:}
    ;


//functions
func_dcl ::=
    EXTERN function_return_type ID SEMI //todo
    |
    FUNCTION function_return_type:t ID:id {:id = scanner.string.toString();:} PRANTOP arguments PRANTCL func_dcl_part:b {:RESULT = new FunctionDCL(t, id, b);:}
    ;

func_dcl_part ::=
    SEMI {:RESULT = null;:}
    |
    block:b {:RESULT = b;:}
    ;

arguments ::=
    variable_type:t ID:id {:id = scanner.string.toString();:} function_array_dcl:b {:t = b ? Type.toArray(t) : t;:} arguments_part {:FunctionArguments.getInstance().addArgument(id, t);:}
    |
    /*epsilon*/
    ;

arguments_part ::=
     COMA arguments
     |
     /*epsilon*/
    ;

function_array_dcl ::=
    BRACKOP BRACKCL function_array_dcl {:RESULT = true;:}
    |
    /*epsilon*/ {:RESULT = false;:}
    ;

function_return_type ::=
    function_argument_type:t {:RESULT = t;:}
    |
    VOID  {:RESULT = Type.VOID;:}
    ;

function_argument_type ::=
    BOOL {:RESULT = Type.BOOL;:}
    |
    CHAR {:RESULT = Type.CHAR;:}
    |
    INT {:RESULT = Type.INT;:}
    |
    LONG {:RESULT = Type.LONG;:}
    |
    FLOAT {:RESULT = Type.FLOAT;:}
    |
    DOUBLE {:RESULT = Type.DOUBLE;:}
    |
    STRING {:RESULT = Type.STRING;:}
    ;


//structurs
struct_dcl ::=
    RECORD {:Structures.getInstance().init();:} ID:id BEGIN struct_var_dcl:dcl {:Structures.getInstance().addDCL(dcl);:} struct_more_var_dcl END RECORD SEMI {:RESULT = Structures.getInstance().getDCL(id);:}
    ;

struct_more_var_dcl ::=
    struct_var_dcl:dcl {:Structures.getInstance().addDCL(dcl);:} struct_more_var_dcl
    |
    /*epsilon*/
    ;

struct_var_dcl ::=
    CONST struct_var_dcl_part:dcl SEMI {:dcl.getDescriptor().setConst(true); RESULT = dcl;:}
    |
    struct_var_dcl_part:dcl SEMI {:dcl.getDescriptor().setConst(false); RESULT = dcl;:}
    ;

struct_var_dcl_part ::=
    struct_type:t ID:id {:id = scanner.string.toString();:} struct_var_dcl_cnt:dcl {:dcl.getDescriptor().setType(t); dcl.getDescriptor().setName(id); RESULT = dcl;:}
    ;

struct_var_dcl_cnt ::=
    ASSIGN const_val:c {:RESULT = new StructVarDCL(c);:}
    |
    /*epsilon*/ {:RESULT = new StructVarDCL(null);:}
    ;

struct_type ::=
    BOOL {:RESULT = StructureType.BOOL;:}
    |
    CHAR {:RESULT = Type.CHAR;:}
    |
    INT {:RESULT = Type.INT;:}
    |
    LONG {:RESULT = StructureType.LONG;:}
    |
    FLOAT {:RESULT = Type.FLOAT;:}
    |
    DOUBLE {:RESULT = Type.DOUBLE;:}
    ;


//blocks
block ::=
    BEGIN block_content END
    ;

block_content ::=
    var_dcl block_content
    |
    statement:cont block_content {:Blocks.getInstance().getCurrent().addContent(cont);:}
    |
    /*epsilon*/
    ;

loop_block ::=
    BEGIN loop_block_content END
    ;

loop_block_content ::=
    var_dcl loop_block_content
    |
    loop_statement:cont loop_block_content {:Blocks.getInstance().getCurrent().addContent(cont);:}
    |
    /*epsilon*/
    ;


//variables
var_dcl ::=
    CONST {:Variables.getInstance().setConstant(true);:} var_dcl_part SEMI {:Variables.getInstance().setConstant(false);:}
    |
    var_dcl_part SEMI
    ;

var_dcl_part ::=
    variable_type:t {:Variables.getInstance().setType(t);:} var_dcl_cnt:cont {:Blocks.getInstance().getCurrent().addContent(cont);:} var_dcl_cnt_extension
    ;

var_dcl_cnt ::=
    single_var:dcl var_dcl_cnt_part:e {:RESULT = new CompleteDCL(dcl, e);:}
    ;

var_dcl_cnt_part ::=
    ASSIGN constant:e {:RESULT = e;:}
    |
    /*epsilon*/ {:RESULT = null;:}
    ;

var_dcl_cnt_extension ::=
    COMA var_dcl_cnt:cont {:Blocks.getInstance().getCurrent().addContent(cont);:} var_dcl_cnt_extension
    |
    /*epsilon*/
    ;

single_var ::=
    ID:id {:id = scanner.string.toString();:} array_part:dcl {:dcl.setId(id); RESULT = dcl;:}
    ;

array_part ::=
    BRACKOP constant:e BRACKCL array_part {:RESULT = new ArrayVarDCL(e);:}
    |
    /*epsilon*/ {:RESULT = new VariableDCL();:}
    ;


//statements
statement ::=
    cond_stmt:stmt {:RESULT = stmt;:}
    |
    loop_stmt:stmt {:RESULT = stmt;:}
    |
    assignment:stmt SEMI {:RESULT = stmt;:}
    |
    function_call:a SEMI {:RESULT = new FunctionCall(a);:}
    |
    RETURN constant:e SEMI {:RESULT = new Return(e);:}
    ;

loop_statement ::=
    statement:stmt {:RESULT = stmt;:}
    |
    BREAK SEMI {:new Break();:}
    |
    CONTINUE SEMI {:new Continue();:}
    ;


//conditionals
cond_stmt ::=
    IF PRANTOP constant:e PRANTCL block:ifb else_part:eb {:RESULT = new If(e, ifb, eb);:}
    |
    SWITCH PRANTOP variable:a {:Cases.getInstance().init();:} PRANTCL OF COL BEGIN case_part DEFAULT COL block:db END {:RESULT = new Switch(a, db);:}
    ;

else_part ::=
    ELSE block:b {:RESULT = b;:}
    |
    /*epsilon*/ {:RESULT = null;:}
    ;

case_part ::=
    CASE INT_LIT:i {:i = scanner.ICV;:} COL block:b {:Cases.getInstance().addCase(i, b);:} case_part
    |
    /*epsilon*/
    ;


//loops
loop_stmt ::=
    FOR PRANTOP loop_init_part:in SEMI loop_cond_part:e SEMI loop_update_part:up PRANTCL loop_block:b {:RESULT = new For(in, e, up, b);:}
    |
    REPEAT loop_block:b UNTIL PRANTOP constant:e PRANTCL SEMI {:RESULT = new Repeat(b, e);:}
    |
    FOREACH PRANTOP ID:i1 {:i1 = scanner.string.toString();:} IN ID:i2 {:i2 = scanner.string.toString();:} PRANTCL loop_block:b {:RESULT = new Foreach(i1, i2, b);:}
    ;

loop_init_part ::=
    assignment:a {:RESULT = a;:}
    |
    /*epsilon*/ {:RESULT = null;:}
    ;

loop_cond_part ::=
    constant:e {:RESULT = e;:}
    |
    /*epsilon*/ {:RESULT = null;:}
    ;

loop_update_part ::=
    assignment:a {:RESULT = a;:}
    |
    /*epsilon*/ {:RESULT = null;:}
    ;


//assignments
assignment ::=
    variable:a ASSIGN constant:e {:RESULT = new DirectAssign(a, e);:}
    |
    variable:a PLUSASSIGN constant:e {:RESULT = new PlusAssign(a, e);:}
    |
    variable:a MINUSASSIGN constant:e {:RESULT = new MinusAssign(a, e);:}
    |
    variable:a MULTASSIGN constant:e {:RESULT = new MultiplyAssign(a, e);:}
    |
    variable:a DIVASSIGN constant:e {:RESULT = new DivisionAssign(a, e);:}
    ;

variable ::=
    var_access:a {:RESULT = a;:}
    |
    variable:a DOT ID:id {:id = scanner.string.toString(); RESULT = new StructureAccess(a); RESULT.setDescriptor(id);:}
    ;

var_access ::=
    ID:id var_access_array_part:a {:a.setDescriptor(id); RESULT = a;:}
    ;

var_access_array_part ::=
    BRACKOP constant:e BRACKCL array_part {:RESULT = new ArrayAccess(e);:}
    |
    /*epsilon*/ {:RESULT = new VariableAccess();:}
    ;

//expressions
constant ::=
    const_val:e {:RESULT = e;:}
    |
    PRANTOP constant:e PRANTCL {:RESULT = e;:}
    |
    NOT constant:e {:RESULT = new Not(e);:}
    |
    BINOT constant:e {:RESULT = new BinaryNot(e);:}
    |
    MINUS constant:e {:RESULT = new Uminus(e);:} %prec UMINUS
    |
    PREFMINUS2 variable:a {:RESULT = new PrefixMinus2(a);:}
    |
    PREFPLUS2 variable:a {:RESULT = new PrefixPlus2(a);:}
    |
    variable:a PREFMINUS2 {:RESULT = new PostfixMinus2(a);:} %prec POSTMINUS2
    |
    variable:a PREFPLUS2 {:RESULT = new PostfixPlus2(a);:} %prec POSTPLUS2
    |
    PRANTOP casting_type:t PRANTCL constant:e {:RESULT = new Casting(t, e);:} %prec CASTPRANTOP
    |
    SIZEOF PRANTOP variable_type:t PRANTCL {:RESULT = new SizeOf(t);:}
    |
    arithmatic_expr:e {:RESULT = e;:}
    |
    conditional_expr:e {:RESULT = e;:}
    |
    variable:a {:RESULT = new Variable(a);:}
    |
    function_call:a {:RESTULT = new FunctionCall(a);:}
    ;

casting_type ::=
    CHAR {:RESULT = Type.CHAR;:}
    |
    INT {:RESULT = Type.INT;:}
    |
    FLOAT {:RESULT = Type.FLOAT;:}
    |
    DOUBLE {:RESULT = Type.DOUBLE;:}
    ;

arithmatic_expr ::=
    constant:e1 MULT constant:e2 {:RESULT = new Mult(e1, e2);:}
    |
    constant:e1 DIVIDE constant:e2 {:RESULT = new Div(e1, e2);:}
    |
    constant:e1 MOD constant:e2 {:RESULT = new Mod(e1, e2);:}
    |
    constant:e1 PLUS constant:e2 {:RESULT = new Add(e1, e2);:}
    |
    constant:e1 MINUS constant:e2 {:RESULT = new Sub(e1, e2);:}
    |
    constant:e1 BIAND constant:e2 {:RESULT = new BinaryAnd(e1, e2);:}
    |
    constant:e1 BIOR constant:e2 {:RESULT = new BinaryOr(e1, e2);:}
    |
    constant:e1 BIEXOR constant:e2 {:RESULT = new BinaryXor(e1, e2);:}
    ;

conditional_expr ::=
    constant:e1 LT constant:e2 {:RESULT = new LT(e1, e2);:}
    |
    constant:e1 LTEQ constant:e2 {:RESULT = new LE(e1, e2);:}
    |
    constant:e1 GT constant:e2 {:RESULT = new GT(e1, e2);:}
    |
    constant:e1 GTEQ constant:e2 {:RESULT = new GE(e1, e2);:}
    |
    constant:e1 EQEQ constant:e2 {:RESULT = new EQ(e1, e2);:}
    |
    constant:e1 NOTEQ constant:e2 {:RESULT = new NE(e1, e2);:}
    |
    constant:e1 AND constant:e2 {:RESULT = new BinaryAnd(e1, e2);:}
    |
    constant:e1 OR constant:e2 {:RESULT = new BinaryOr(e1, e2);:}
    ;

const_val ::=
    TRUE {:RESULT = new BooleanConstant(true);:}
    |
    FALSE {:RESULT = new BooleanConstant(false);:}
    |
    CHAR_LIT {:RESULT = new CharConstant(scanner.string);:}
    |
    INT_LIT {:RESULT = new IntegerConstant(scanner.ICV);:}
    |
    FLOAT_LIT {:RESULT = new DoubleConstant(scanner.RCV);:}
    |
    STR_LIT {:RESULT = new StringConstant(scanner.string);:}
    ;


//function calls
function_call ::=
    ID:id {:FunctionAccessData.getInstance().init(); id = scanner.string.toString();:} PRANTOP parameters PRANTCL {:RESULT = new FunctionAccess(); RESULT.setDescriptor(id);:} %prec FUNCPRANTOP
    ;

parameters ::=
    constant:e {:FunctionAccessData.getInstance().addParameter(e);:} parameters_part
    |
    /*epsilon*/
    ;

parameters_part ::=
    COMA parameters
    |
    /*epsilon*/
    ;